pipeline {
  agent any

  environment { 
    DOCKER_IMAGE     = 'analyser'
    DOCKERHUB_REPO   = 'adishjain1107/analyser'
    EC2_USER         = 'ubuntu'
    EC2_IP           = '18.209.55.68'
    EC2_SSH_KEY      = credentials('EC2_KEY')
    DOCKERHUB_CREDS  = credentials('dockerhub-credentials')
//  SONAR_TOKEN     = credentials('sonar-token')
    REPO_URL         = 'https://github.com/1107-adishjain/Analyser.git'
    REMOTE_DIR       = '/home/ubuntu/analyser'
    COMPOSE_DIR      = 'docker'
    BUILD_NUMBER     = "${env.BUILD_NUMBER}"
  }

  stages {
    stage('Checkout') {
      steps {
        git url: "${REPO_URL}", branch: 'main'
        echo "üîÑ Code checked out successfully"
      }
    }
    
    stage('Lint Code') {
      steps {
        dir('docker') {
          sh 'npm run lint || echo "Linting completed with warnings"'
        }
        echo "‚úÖ Code linting completed"
      }
    }

    // SonarQube stages commented out but kept for reference
    // stage('SonarQube Analysis') {
    //   steps {
    //     withCredentials([string(credentialsId: 'sonar-token', variable: 'SQ_TOKEN')]) {
    //       sh """
    //         sonar-scanner \
    //           -Dsonar.projectKey=analyser-project \
    //           -Dsonar.sources=src \
    //           -Dsonar.host.url=http://localhost:9000 \
    //           -Dsonar.login=$SQ_TOKEN \
    //           -Dsonar.exclusions=node_modules/**,docker/**
    //       """
    //     }
    //   }
    // }

    // stage('Quality Gate') {
    //   steps {
    //     timeout(time: 30, unit: 'MINUTES') {
    //       waitForQualityGate abortPipeline: true
    //     }
    //   }
    // }

    stage('Build Docker Image') {
      steps {
        sh '''
          cd docker
          docker build -f Dockerfile -t ${DOCKERHUB_REPO}:${BUILD_NUMBER} ..
          docker tag ${DOCKERHUB_REPO}:${BUILD_NUMBER} ${DOCKERHUB_REPO}:latest
        '''
        echo "üê≥ Docker image built successfully"
      }
    }

    stage('Push to DockerHub') {
      steps {
        withCredentials([usernamePassword(credentialsId: 'dockerhub-credentials',
                                          usernameVariable: 'DH_USER',
                                          passwordVariable: 'DH_PSW')]) {
          sh '''
            echo "$DH_PSW" | docker login -u "$DH_USER" --password-stdin
            
            # Check if image already exists on DockerHub
            if docker manifest inspect ${DOCKERHUB_REPO}:${BUILD_NUMBER} > /dev/null 2>&1; then
              echo "üîç Image already exists, skipping build-specific push"
            else
              echo "üì§ Pushing new image..."
              docker push ${DOCKERHUB_REPO}:${BUILD_NUMBER}
            fi
            
            # Always update latest tag
            echo "üì§ Updating latest tag..."
            docker tag ${DOCKERHUB_REPO}:${BUILD_NUMBER} ${DOCKERHUB_REPO}:latest
            
            # Push latest with retry mechanism
            for attempt in 1 2 3; do
              if docker push ${DOCKERHUB_REPO}:latest; then
                echo "‚úÖ Latest tag updated successfully on attempt $attempt"
                break
              else
                echo "‚ö†Ô∏è  Latest push attempt $attempt failed, retrying in $((attempt*5)) seconds..."
                sleep $((attempt*5))
                if [ $attempt -eq 3 ]; then
                  echo "‚ùå Failed to push latest after 3 attempts"
                  exit 0
                fi
              fi
            done
            
            docker logout
          '''
        }
        echo "üöÄ Images pushed to DockerHub successfully"
      }
    }

    stage('Deploy to EC2') {
      steps {
        withCredentials([
          string(credentialsId: 'supabase-url', variable: 'SUPABASE_URL'),
          string(credentialsId: 'supabase-anon-key', variable: 'SUPABASE_ANON_KEY')
        ]) {
          sshagent (credentials: ['EC2_KEY']) {
            sh """
              ssh -o StrictHostKeyChecking=no ${EC2_USER}@${EC2_IP} "
                set -e
                echo 'Starting deployment on EC2...'
                
                [ -d '${REMOTE_DIR}' ] || git clone ${REPO_URL} ${REMOTE_DIR}
                
                cd '${REMOTE_DIR}'
                git reset --hard
           
                git pull origin main
                
                cd '${COMPOSE_DIR}'
                
                # FIX: Use printf instead of heredoc to avoid syntax issues
                printf 'NEXT_PUBLIC_SUPABASE_URL=%s\\nNEXT_PUBLIC_SUPABASE_ANON_KEY=%s\\n' '${SUPABASE_URL}' '${SUPABASE_ANON_KEY}' > .env.production
                
                # Verify file creation
                echo 'Environment file created:'
                cat .env.production
                
                # Restart containers
                docker compose pull
                docker compose down || true
                docker compose up -d
                
                echo 'Deployment completed successfully!'
              "
            """
          }
        }
      }
    }
}
  post {
    always {
      sh '''
        echo "üßπ Cleaning up Jenkins server..."
        docker system prune -f
        docker image prune -a -f
        docker logout || true
      '''
    }
    success {
      echo '‚úÖ Deployment successful!'
    }
    failure {
      echo '‚ùå Deployment failed.'
    }
  }
} 
